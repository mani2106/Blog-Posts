<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Azure AI-102 Certification Journey - Day 2 - Plan and prepare to develop AI solutions on Azure | Manimaran Panneerselvam’s blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Azure AI-102 Certification Journey - Day 2 - Plan and prepare to develop AI solutions on Azure" />
<meta name="author" content="Manimaran Panneerselvam" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction" />
<meta property="og:description" content="Introduction" />
<link rel="canonical" href="https://mani2106.github.io/Blog-Posts/azure/azure-ai/ai-102/2025/11/17/Azure-AI102-Day2-Planning-AI-Soln-Azure.html" />
<meta property="og:url" content="https://mani2106.github.io/Blog-Posts/azure/azure-ai/ai-102/2025/11/17/Azure-AI102-Day2-Planning-AI-Soln-Azure.html" />
<meta property="og:site_name" content="Manimaran Panneerselvam’s blog" />
<meta property="og:image" content="https://mani2106.github.io/Blog-Posts/images/Azure_day2/fairness.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-11-17T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://mani2106.github.io/Blog-Posts/images/Azure_day2/fairness.png" />
<meta property="twitter:title" content="Azure AI-102 Certification Journey - Day 2 - Plan and prepare to develop AI solutions on Azure" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Manimaran Panneerselvam"},"dateModified":"2025-11-17T00:00:00+00:00","datePublished":"2025-11-17T00:00:00+00:00","description":"Introduction","headline":"Azure AI-102 Certification Journey - Day 2 - Plan and prepare to develop AI solutions on Azure","image":"https://mani2106.github.io/Blog-Posts/images/Azure_day2/fairness.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://mani2106.github.io/Blog-Posts/azure/azure-ai/ai-102/2025/11/17/Azure-AI102-Day2-Planning-AI-Soln-Azure.html"},"url":"https://mani2106.github.io/Blog-Posts/azure/azure-ai/ai-102/2025/11/17/Azure-AI102-Day2-Planning-AI-Soln-Azure.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/Blog-Posts/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://mani2106.github.io/Blog-Posts/feed.xml" title="Manimaran Panneerselvam&apos;s blog" /><!-- the google_analytics_id gets auto inserted from the config file -->



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-168240544-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-168240544-1');
</script>




<script>
(function() {
  const theme = localStorage.getItem('theme-preference') || 'auto';
  if (theme === 'dark' || (theme === 'auto' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
    document.documentElement.setAttribute('data-theme', 'dark');
  } else {
    document.documentElement.setAttribute('data-theme', 'light');
  }
})();
</script><link rel="shortcut icon" type="image/x-icon" href="/Blog-Posts/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>

<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

<script src="/Blog-Posts/assets/js/theme-toggle.js"></script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/Blog-Posts/">Manimaran Panneerselvam&#39;s blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/Blog-Posts/about/">About Me</a><a class="page-link" href="/Blog-Posts/search/">Search</a><a class="page-link" href="/Blog-Posts/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Azure AI-102 Certification Journey - Day 2 - Plan and prepare to develop AI solutions on Azure</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2025-11-17T00:00:00+00:00" itemprop="datePublished">
        Nov 17, 2025
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      4 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i>
      
        <a class="category-tags-link" href="/Blog-Posts/categories/#azure">azure</a>
        &nbsp;
      
        <a class="category-tags-link" href="/Blog-Posts/categories/#azure-ai">azure-ai</a>
        &nbsp;
      
        <a class="category-tags-link" href="/Blog-Posts/categories/#AI-102">AI-102</a>
        
      
      </p>
    

    </header>

  <div class="post-container">
    <aside class="toc-sidebar">
      <!-- Enhanced Table of Contents with proper semantic HTML structure and accessibility -->
<div class="toc-container" role="complementary" aria-labelledby="toc-heading">
  <div class="toc-header">
    <h4 id="toc-heading" class="toc-title">Table of Contents</h4>
  </div>
  <nav class="toc-nav" aria-label="Table of Contents">
    <div id="toc" role="navigation"></div>
  </nav>
  <div class="toc-resize-handle" title="Drag to resize" tabindex="0" role="separator"
    aria-label="Resize table of contents" aria-orientation="vertical"></div>
</div>

<script>
  // Performance optimization: Debounce utility for scroll handlers (Requirement 3.4)
  function debounce(func, wait, immediate) {
    var timeout;
    return function executedFunction() {
      var context = this;
      var args = arguments;
      var later = function () {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
    };
  }

  // Performance optimization: Throttle utility for high-frequency events
  function throttle(func, limit) {
    var inThrottle;
    return function () {
      var args = arguments;
      var context = this;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(function () { inThrottle = false; }, limit);
      }
    };
  }

  // Performance optimization: RequestAnimationFrame polyfill for smooth animations
  (function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
      window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||
        window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function (callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function () { callback(currTime + timeToCall); }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }

    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
      };
    }
  })();

  // Enhanced feature detection with polyfill support (Requirement 5.2)
  var features = {
    jquery: typeof jQuery !== 'undefined',
    cssGrid: (function () {
      try {
        return CSS && CSS.supports && CSS.supports('display', 'grid');
      } catch (e) {
        return false;
      }
    })(),
    stickyPosition: (function () {
      try {
        return CSS && CSS.supports && (
          CSS.supports('position', 'sticky') ||
          CSS.supports('position', '-webkit-sticky')
        );
      } catch (e) {
        return false;
      }
    })(),
    intersectionObserver: (function () {
      try {
        return 'IntersectionObserver' in window &&
          typeof IntersectionObserver === 'function';
      } catch (e) {
        return false;
      }
    })(),
    smoothScroll: (function () {
      try {
        return 'scrollBehavior' in document.documentElement.style;
      } catch (e) {
        return false;
      }
    })(),
    // Additional performance-related feature detection
    passiveEvents: (function () {
      try {
        var opts = Object.defineProperty({}, 'passive', {
          get: function () {
            return true;
          }
        });
        window.addEventListener('testPassive', null, opts);
        window.removeEventListener('testPassive', null, opts);
        return true;
      } catch (e) {
        return false;
      }
    })(),
    requestAnimationFrame: typeof window.requestAnimationFrame === 'function'
  };

  // Log feature support for debugging
  console.log('TOC Feature Support:', features);

  // Apply graceful degradation classes based on feature support (Requirement 5.3)
  function applyFeatureDegradation() {
    var tocContainer = document.querySelector('.toc-container');
    if (!tocContainer) return;

    // Add classes for CSS to handle graceful degradation
    if (!features.cssGrid) {
      tocContainer.classList.add('no-css-grid');
    }
    if (!features.stickyPosition) {
      tocContainer.classList.add('no-sticky-position');
    }
    if (!features.intersectionObserver) {
      tocContainer.classList.add('no-intersection-observer');
    }
  }

  // Fallback TOC generation if jQuery plugin fails (Requirement 5.1)
  // Enhanced with stack-based algorithm for proper heading hierarchy (Requirements 4.1-4.5)
  function generateFallbackTOC() {
    try {
      // Select all heading levels H2-H6 (Requirement 4.1)
      var headers = document.querySelectorAll('h2, h3, h4, h5, h6');

      // Hide TOC if fewer than 2 headers (Requirement 1.4)
      if (headers.length < 2) {
        hideTOCContainer();
        return false;
      }

      var tocContainer = document.getElementById('toc');
      if (!tocContainer) {
        console.warn('TOC container not found');
        return false;
      }

      // Clear existing content
      tocContainer.innerHTML = '';

      // Build hierarchical structure using stack-based algorithm (Requirement 4.2, 4.3)
      var rootList = document.createElement('ul');
      var stack = [{ level: 1, list: rootList }]; // Stack to track nesting levels

      headers.forEach(function (header, index) {
        // Auto-generate IDs for headings without IDs (Requirement 4.4)
        if (!header.id) {
          header.id = 'toc-header-' + index;
        }

        var level = parseInt(header.tagName.charAt(1)); // Extract level (2-6)
        var listItem = document.createElement('li');
        var link = document.createElement('a');

        link.href = '#' + header.id;
        link.textContent = header.textContent || header.innerText;
        link.setAttribute('data-level', level);
        listItem.appendChild(link);

        // Handle non-sequential heading hierarchies gracefully (Requirement 4.3)
        // Find the correct parent level in the stack
        while (stack.length > 1 && stack[stack.length - 1].level >= level) {
          stack.pop();
        }

        // If we need to go deeper, create nested lists for proper indentation (Requirement 4.5)
        if (level > stack[stack.length - 1].level) {
          // Create nested list structure
          var nestedList = document.createElement('ul');
          var parentList = stack[stack.length - 1].list;

          // Append to last item in parent list, or to parent list if empty
          if (parentList.lastElementChild) {
            parentList.lastElementChild.appendChild(nestedList);
          } else {
            // Handle case where parent header is missing (non-sequential hierarchy)
            parentList.appendChild(nestedList);
          }

          // Push new level onto stack
          stack.push({ level: level, list: nestedList });
        }

        // Append item to current level
        stack[stack.length - 1].list.appendChild(listItem);
      });

      tocContainer.appendChild(rootList);

      // Add click handlers for smooth scrolling
      addFallbackScrollHandlers();

      console.log('Fallback TOC generated successfully with all heading levels (H2-H6)');
      return true;
    } catch (error) {
      console.error('Fallback TOC generation failed:', error);
      hideTOCContainer();
      return false;
    }
  }

  // Add smooth scrolling handlers for fallback TOC (Requirement 5.1)
  function addFallbackScrollHandlers() {
    var tocLinks = document.querySelectorAll('#toc a');

    tocLinks.forEach(function (link) {
      // Create named handler for cleanup
      var clickHandler = function (e) {
        try {
          e.preventDefault();

          var targetId = this.getAttribute('href').substring(1);
          var target = document.getElementById(targetId);

          if (target) {
            var offset = 32; // Account for sticky headers
            var targetPosition = target.offsetTop - offset;

            // Use smooth scroll if supported, otherwise fallback to instant scroll
            if (features.smoothScroll) {
              window.scrollTo({
                top: targetPosition,
                behavior: 'smooth'
              });
            } else {
              window.scrollTo(0, targetPosition);
            }
          }
        } catch (scrollError) {
          console.warn('Error in fallback scroll handler:', scrollError);
          // Allow default browser behavior as fallback
          return true;
        }
        return false;
      };

      // Store handler reference for cleanup
      link._tocClickHandler = clickHandler;
      link.addEventListener('click', clickHandler);
    });
  }

  // Hide TOC container when not needed (Requirement 1.4)
  function hideTOCContainer() {
    var tocContainer = document.querySelector('.toc-container');
    if (tocContainer) {
      tocContainer.style.display = 'none';
    }
  }

  // Show TOC container with loading state management
  function showTOCContainer() {
    var tocContainer = document.querySelector('.toc-container');
    if (tocContainer) {
      tocContainer.style.display = 'block';
      // Remove loading state if present
      tocContainer.classList.remove('toc-loading');
      tocContainer.classList.add('toc-loaded');
    }
  }

  // Add loading state to TOC container
  function showTOCLoading() {
    var tocContainer = document.querySelector('.toc-container');
    if (tocContainer) {
      tocContainer.classList.add('toc-loading');
      tocContainer.classList.remove('toc-loaded');

      // Add loading indicator
      var tocContent = document.getElementById('toc');
      if (tocContent) {
        tocContent.innerHTML = '<div class="toc-loading-indicator">' +
          '<div class="toc-spinner"></div>' +
          '<span>Generating table of contents...</span>' +
          '</div>';
      }
    }
  }

  // Performance optimization: Batch DOM operations for faster TOC generation
  function batchDOMOperations(operations) {
    if (features.requestAnimationFrame) {
      return new Promise(function (resolve) {
        requestAnimationFrame(function () {
          operations();
          resolve();
        });
      });
    } else {
      // Fallback for browsers without requestAnimationFrame
      return new Promise(function (resolve) {
        setTimeout(function () {
          operations();
          resolve();
        }, 0);
      });
    }
  }

  // Error recovery and cleanup utilities (Requirement 5.1)
  var tocErrorCount = 0;
  var maxRetries = 3;

  function handleTOCError(error, context) {
    tocErrorCount++;
    console.error('TOC Error in ' + context + ':', error);

    if (tocErrorCount >= maxRetries) {
      console.error('TOC initialization failed after ' + maxRetries + ' attempts, disabling TOC');
      hideTOCContainer();
      return false;
    }

    return true;
  }

  // Cross-browser compatibility: Array.from polyfill for IE11
  if (!Array.from) {
    Array.from = function (arrayLike) {
      var result = [];
      for (var i = 0; i < arrayLike.length; i++) {
        result.push(arrayLike[i]);
      }
      return result;
    };
  }

  // Cross-browser compatibility: forEach polyfill for NodeList in IE11
  if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = function (callback, thisArg) {
      thisArg = thisArg || window;
      for (var i = 0; i < this.length; i++) {
        callback.call(thisArg, this[i], i, this);
      }
    };
  }

  // Cross-browser compatibility: Object.assign polyfill for IE11
  if (typeof Object.assign !== 'function') {
    Object.assign = function (target) {
      if (target == null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }
      var to = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];
        if (nextSource != null) {
          for (var nextKey in nextSource) {
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    };
  }

  // Enhanced cleanup function for memory management and performance
  function cleanupTOC() {
    try {
      // Performance optimization: Cancel any pending animation frames
      if (window.tocAnimationFrame) {
        cancelAnimationFrame(window.tocAnimationFrame);
        window.tocAnimationFrame = null;
      }

      // Remove event listeners to prevent memory leaks
      var tocLinks = document.querySelectorAll('#toc a');
      tocLinks.forEach(function (link) {
        if (link._tocClickHandler) {
          link.removeEventListener('click', link._tocClickHandler);
          delete link._tocClickHandler;
        }
      });

      // Clear any active observers
      if (window.tocObserver) {
        window.tocObserver.disconnect();
        window.tocObserver = null;
      }

      // Clear timeouts and intervals
      if (window.tocScrollTimeout) {
        clearTimeout(window.tocScrollTimeout);
        window.tocScrollTimeout = null;
      }
      if (window.tocResizeTimeout) {
        clearTimeout(window.tocResizeTimeout);
        window.tocResizeTimeout = null;
      }

      // Clear performance monitoring
      if (window.tocPerformanceStart) {
        window.tocPerformanceStart = null;
      }

      console.log('TOC cleanup completed');
    } catch (cleanupError) {
      console.warn('Error during TOC cleanup:', cleanupError);
    }
  }

  // Main TOC initialization with comprehensive error handling and performance optimization
  function initializeTOC() {
    try {
      // Performance optimization: Show loading state immediately
      showTOCLoading();

      // Clean up any previous initialization
      cleanupTOC();

      // Apply feature degradation classes first
      applyFeatureDegradation();

      // Performance optimization: Use requestAnimationFrame for non-blocking execution
      return batchDOMOperations(function () {
        // Check if we have enough headers (Requirement 1.4)
        var headers = document.querySelectorAll('h2, h3, h4, h5, h6');
        if (headers.length < 2) {
          console.log('TOC hidden: fewer than 2 headers found (' + headers.length + ')');
          hideTOCContainer();
          return;
        }

        console.log('Initializing TOC with ' + headers.length + ' headers');

        // Performance monitoring: Track TOC generation time
        window.tocPerformanceStart = performance && performance.now ? performance.now() : Date.now();

        var tocGenerated = false;

        // Try jQuery TOC plugin first if available
        if (features.jquery && typeof $ !== 'undefined' && $.fn && typeof $.fn.toc === 'function') {
          try {
            $('#toc').toc({
              minimumHeaders: 2,
              listType: 'ul',
              showSpeed: 0,
              headers: 'h2,h3,h4,h5,h6'
            });

            // Check if TOC was actually generated
            var tocContent = document.querySelector('#toc ul');
            if (tocContent && tocContent.children.length > 0) {
              tocGenerated = true;
              console.log('jQuery TOC plugin initialized successfully');

              // Enhanced smooth scrolling with proper offset calculation (Requirements 3.2, 3.3)
              $('#toc').on('click', 'a', function (e) {
                try {
                  e.preventDefault();
                  var target = $(this.getAttribute('href'));

                  if (target.length) {
                    var scroll_target = target.offset().top;
                    var offset = 32; // 2rem equivalent for sticky positioning

                    if (features.smoothScroll) {
                      $('html, body').animate({
                        scrollTop: scroll_target - offset
                      }, 300, 'swing');
                    } else {
                      // Fallback for browsers without smooth scroll
                      $('html, body').scrollTop(scroll_target - offset);
                    }
                  }
                } catch (scrollError) {
                  console.warn('Error in jQuery scroll handler:', scrollError);
                  // Fallback to browser default behavior
                  return true;
                }
                return false;
              });
            } else {
              console.warn('jQuery TOC plugin did not generate content');
            }
          } catch (jqueryError) {
            if (!handleTOCError(jqueryError, 'jQuery TOC plugin')) return;
          }
        } else {
          console.log('jQuery TOC plugin not available, using fallback');
        }

        // Fallback to vanilla JavaScript TOC generation if jQuery failed (Requirement 5.1)
        if (!tocGenerated) {
          console.log('Falling back to vanilla JavaScript TOC generation');
          try {
            tocGenerated = generateFallbackTOC();
          } catch (fallbackError) {
            if (!handleTOCError(fallbackError, 'fallback TOC generation')) return;
          }
        }

        if (tocGenerated) {
          try {
            // Initialize active section highlighting if supported (Requirements 3.1, 3.4)
            initializeActiveHighlighting();
            showTOCContainer();

            // Performance monitoring: Log completion time
            if (window.tocPerformanceStart) {
              var endTime = performance && performance.now ? performance.now() : Date.now();
              var duration = endTime - window.tocPerformanceStart;
              console.log('TOC initialization completed in ' + duration.toFixed(2) + 'ms');

              // Performance validation: Warn if TOC generation is slow (Requirement 3.4)
              if (duration > 50) {
                console.warn('TOC generation took longer than expected (' + duration.toFixed(2) + 'ms). Consider optimizing for better performance.');
              }
            }

            // Validate final implementation against requirements
            validateTOCImplementation();

          } catch (highlightError) {
            // Active highlighting is optional, don't fail the entire TOC
            console.warn('Active highlighting failed, but TOC is still functional:', highlightError);
            showTOCContainer();
          }
        } else {
          console.warn('TOC generation failed, hiding container');
          hideTOCContainer();
        }
      }).catch(function (batchError) {
        console.error('Error in batched TOC operations:', batchError);
        hideTOCContainer();
      });

    } catch (error) {
      handleTOCError(error, 'main initialization');
    }
  }

  // Cleanup on page unload to prevent memory leaks
  window.addEventListener('beforeunload', cleanupTOC);

  // Validate final implementation against all requirements
  function validateTOCImplementation() {
    try {
      var validationResults = {
        requirement1_1: false, // TOC displays in right sidebar
        requirement1_2: false, // TOC remains sticky during scroll
        requirement1_3: false, // TOC hidden on mobile/tablet
        requirement1_4: false, // TOC hidden when fewer than 2 headers
        requirement3_1: false, // Active section highlighting
        requirement3_4: false, // Smooth scrolling with proper performance
        requirement4_1: false, // Consistent typography and colors
        requirement6_4: false  // Responsive behavior
      };

      // Check Requirement 1.1: TOC displays in right sidebar
      var tocSidebar = document.querySelector('.toc-sidebar');
      var tocContainer = document.querySelector('.toc-container');
      if (tocSidebar && tocContainer && tocContainer.style.display !== 'none') {
        validationResults.requirement1_1 = true;
      }

      // Check Requirement 1.2: Sticky positioning
      if (features.stickyPosition) {
        var stickyStyle = window.getComputedStyle(tocSidebar);
        if (stickyStyle.position === 'sticky' || stickyStyle.position === '-webkit-sticky') {
          validationResults.requirement1_2 = true;
        }
      } else {
        // Graceful degradation is acceptable
        validationResults.requirement1_2 = true;
      }

      // Check Requirement 1.3: Responsive behavior
      var mediaQuery = window.matchMedia('(max-width: 1024px)');
      if (mediaQuery.matches) {
        var tocDisplay = window.getComputedStyle(tocSidebar).display;
        if (tocDisplay === 'none') {
          validationResults.requirement1_3 = true;
        }
      } else {
        validationResults.requirement1_3 = true; // Not on mobile, so requirement is met
      }

      // Check Requirement 1.4: Hidden when fewer than 2 headers
      var headers = document.querySelectorAll('h2, h3, h4, h5, h6');
      if (headers.length >= 2) {
        validationResults.requirement1_4 = true; // TOC should be visible
      } else {
        // TOC should be hidden
        if (tocContainer && tocContainer.style.display === 'none') {
          validationResults.requirement1_4 = true;
        }
      }

      // Check Requirement 3.1: Active section highlighting
      var tocLinks = document.querySelectorAll('#toc a');
      var hasActiveClass = false;
      tocLinks.forEach(function (link) {
        if (link.classList.contains('toc-active')) {
          hasActiveClass = true;
        }
      });
      if (features.intersectionObserver || hasActiveClass) {
        validationResults.requirement3_1 = true;
      }

      // Check Requirement 3.4: Performance (scroll handlers are throttled)
      if (window.tocObserver || (window.addEventListener.toString().indexOf('throttle') > -1)) {
        validationResults.requirement3_4 = true;
      }

      // Check Requirement 4.1: Typography and colors
      if (tocContainer) {
        var containerStyles = window.getComputedStyle(tocContainer);
        if (containerStyles.fontFamily && containerStyles.color) {
          validationResults.requirement4_1 = true;
        }
      }

      // Check Requirement 6.4: Responsive adaptation
      validationResults.requirement6_4 = validationResults.requirement1_3;

      // Log validation results
      var passedCount = 0;
      var totalCount = 0;
      for (var req in validationResults) {
        totalCount++;
        if (validationResults[req]) {
          passedCount++;
        } else {
          console.warn('Requirement validation failed:', req);
        }
      }

      console.log('TOC Requirements Validation: ' + passedCount + '/' + totalCount + ' requirements met');

      if (passedCount === totalCount) {
        console.log('✅ All TOC requirements successfully validated');
      } else {
        console.warn('⚠️ Some TOC requirements not fully met - check console for details');
      }

      return validationResults;
    } catch (validationError) {
      console.error('Error during TOC validation:', validationError);
      return null;
    }
  }

  // Cross-browser compatibility: Performance monitoring fallback
  if (!window.performance || !window.performance.now) {
    window.performance = {
      now: function () {
        return Date.now();
      }
    };
  }

  // Initialize when DOM is ready with error handling
  function initializeTOCWhenReady() {
    try {
      if (features.jquery && typeof $ !== 'undefined') {
        $(document).ready(function () {
          setTimeout(initializeTOC, 0); // Non-blocking initialization
        });
      } else {
        // Fallback for when jQuery is not available
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', function () {
            setTimeout(initializeTOC, 0); // Non-blocking initialization
          });
        } else {
          setTimeout(initializeTOC, 0); // Non-blocking initialization
        }
      }
    } catch (initError) {
      console.error('Error setting up TOC initialization:', initError);
      // Fallback: try direct initialization
      setTimeout(function () {
        try {
          initializeTOC();
        } catch (fallbackError) {
          console.error('TOC fallback initialization also failed:', fallbackError);
        }
      }, 100);
    }
  }

  // TOC Resize functionality (Requirements 1.1, 1.2, 1.4, 1.5, 3.1, 3.2, 3.3)
  function initTOCResize() {
    try {
      var resizeHandle = document.querySelector('.toc-resize-handle');
      var tocSidebar = document.querySelector('.toc-sidebar');

      if (!resizeHandle || !tocSidebar) {
        console.log('Resize handle or TOC sidebar not found');
        return;
      }

      var isResizing = false;
      var startX = 0;
      var startWidth = 0;
      var minWidth = 200;
      var maxWidth = 400;

      // Load saved width from localStorage
      var savedWidth = localStorage.getItem('toc-width');
      if (savedWidth) {
        var width = parseInt(savedWidth, 10);
        if (width >= minWidth && width <= maxWidth) {
          tocSidebar.style.width = width + 'px';
        }
      }

      // Mouse events for drag-to-resize
      function startResize(e) {
        isResizing = true;
        startX = e.clientX || (e.touches && e.touches[0].clientX);
        startWidth = tocSidebar.offsetWidth;

        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';

        e.preventDefault();
      }

      function doResize(e) {
        if (!isResizing) return;

        var clientX = e.clientX || (e.touches && e.touches[0].clientX);
        var deltaX = clientX - startX;
        var newWidth = startWidth + deltaX;

        // Constrain width
        newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

        tocSidebar.style.width = newWidth + 'px';

        e.preventDefault();
      }

      function stopResize() {
        if (!isResizing) return;

        isResizing = false;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';

        // Save width to localStorage
        localStorage.setItem('toc-width', tocSidebar.offsetWidth);
      }

      // Mouse events
      resizeHandle.addEventListener('mousedown', startResize);
      document.addEventListener('mousemove', doResize);
      document.addEventListener('mouseup', stopResize);

      // Touch events for mobile (though handle is hidden on mobile)
      resizeHandle.addEventListener('touchstart', startResize, { passive: false });
      document.addEventListener('touchmove', doResize, { passive: false });
      document.addEventListener('touchend', stopResize);

      // Keyboard accessibility (Requirements 7.1, 7.2, 7.3)
      resizeHandle.addEventListener('keydown', function (e) {
        var currentWidth = tocSidebar.offsetWidth;
        var step = 10; // 10px per keypress
        var newWidth = currentWidth;

        if (e.key === 'ArrowLeft') {
          newWidth = Math.max(minWidth, currentWidth - step);
          e.preventDefault();
        } else if (e.key === 'ArrowRight') {
          newWidth = Math.min(maxWidth, currentWidth + step);
          e.preventDefault();
        } else {
          return;
        }

        tocSidebar.style.width = newWidth + 'px';
        localStorage.setItem('toc-width', newWidth);
      });

      console.log('TOC resize functionality initialized');
    } catch (error) {
      console.error('Error initializing TOC resize:', error);
    }
  }

  // Start initialization
  initializeTOCWhenReady();

  // Initialize resize after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTOCResize);
  } else {
    initTOCResize();
  }

  // Active section highlighting using Intersection Observer API (Requirement 3.1)
  function initializeActiveHighlighting() {
    try {
      // Check if Intersection Observer is supported (Requirement 5.2)
      if (!features.intersectionObserver) {
        console.warn('Intersection Observer not supported, using fallback scroll-based highlighting');
        initializeFallbackHighlighting();
        return;
      }

      var headers = document.querySelectorAll('h2, h3, h4, h5, h6');
      var tocLinks = document.querySelectorAll('#toc a');
      var activeClass = 'toc-active';

      if (headers.length === 0 || tocLinks.length === 0) {
        console.log('No headers or TOC links found for active highlighting');
        return;
      }

      // Create a map of header IDs to TOC links for efficient lookup
      var headerToLinkMap = {};
      tocLinks.forEach(function (link) {
        try {
          var href = link.getAttribute('href');
          if (href && href.startsWith('#')) {
            var headerId = href.substring(1);
            headerToLinkMap[headerId] = link;
          }
        } catch (linkError) {
          console.warn('Error processing TOC link:', linkError);
        }
      });

      // Intersection Observer configuration (Requirement 3.4)
      var observerOptions = {
        // Trigger when section is in the middle portion of viewport
        rootMargin: '-20% 0px -35% 0px',
        threshold: 0
      };

      // Track currently active section
      var currentActiveLink = null;

      // Intersection Observer callback (Requirement 3.1, 3.4)
      window.tocObserver = new IntersectionObserver(function (entries) {
        try {
          var visibleHeaders = [];

          // Collect all visible headers
          entries.forEach(function (entry) {
            if (entry.isIntersecting) {
              visibleHeaders.push({
                element: entry.target,
                ratio: entry.intersectionRatio,
                top: entry.boundingClientRect.top
              });
            }
          });

          // Sort by position in viewport (topmost first)
          visibleHeaders.sort(function (a, b) {
            return a.top - b.top;
          });

          // Clear previous active state
          if (currentActiveLink) {
            currentActiveLink.classList.remove(activeClass);
            currentActiveLink = null;
          }

          // Set new active state for the topmost visible header (Requirement 3.4)
          if (visibleHeaders.length > 0) {
            var activeHeader = visibleHeaders[0].element;
            var activeLink = headerToLinkMap[activeHeader.id];

            if (activeLink) {
              activeLink.classList.add(activeClass);
              currentActiveLink = activeLink;
            }
          }
        } catch (observerError) {
          console.error('Error in Intersection Observer callback:', observerError);
        }
      }, observerOptions);

      // Start observing all headers (Requirement 3.1)
      headers.forEach(function (header, index) {
        try {
          // Ensure header has an ID for linking
          if (!header.id) {
            // Generate ID if missing (fallback)
            header.id = 'toc-header-' + index;
          }
          window.tocObserver.observe(header);
        } catch (headerError) {
          console.warn('Error observing header:', headerError);
        }
      });

      // Handle edge case: highlight first section when at top of page
      function handleScrollTop() {
        try {
          if (window.pageYOffset < 100 && tocLinks.length > 0) {
            // Clear all active states
            tocLinks.forEach(function (link) {
              link.classList.remove(activeClass);
            });

            // Activate first link
            tocLinks[0].classList.add(activeClass);
            currentActiveLink = tocLinks[0];
          }
        } catch (scrollError) {
          console.warn('Error in scroll top handler:', scrollError);
        }
      }

      // Optimized scroll handler with throttling for 60fps performance (Requirement 3.4)
      var optimizedScrollHandler = throttle(handleScrollTop, 16); // ~60fps
      var eventOptions = features.passiveEvents ? { passive: true } : false;

      window.addEventListener('scroll', optimizedScrollHandler, eventOptions);

      // Initial check
      handleScrollTop();

      console.log('Intersection Observer active highlighting initialized');

    } catch (error) {
      console.error('Error initializing active highlighting:', error);
      // Fallback to scroll-based highlighting
      initializeFallbackHighlighting();
    }
  }

  // Fallback active highlighting for browsers without Intersection Observer (Requirement 5.2, 5.3)
  function initializeFallbackHighlighting() {
    try {
      var headers = document.querySelectorAll('h2, h3, h4, h5, h6');
      var tocLinks = document.querySelectorAll('#toc a');
      var activeClass = 'toc-active';

      if (headers.length === 0 || tocLinks.length === 0) {
        return;
      }

      // Create header position cache for performance
      var headerPositions = [];

      function updateHeaderPositions() {
        headerPositions = Array.from(headers).map(function (header) {
          return {
            element: header,
            top: header.offsetTop,
            id: header.id
          };
        });
      }

      // Create header ID to link mapping
      var headerToLinkMap = {};
      tocLinks.forEach(function (link) {
        var href = link.getAttribute('href');
        if (href && href.startsWith('#')) {
          var headerId = href.substring(1);
          headerToLinkMap[headerId] = link;
        }
      });

      // Scroll-based active highlighting
      function updateActiveSection() {
        try {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
          var currentActive = null;

          // Find the current section based on scroll position
          for (var i = headerPositions.length - 1; i >= 0; i--) {
            if (scrollTop >= headerPositions[i].top - 100) {
              currentActive = headerPositions[i];
              break;
            }
          }

          // Clear all active states
          tocLinks.forEach(function (link) {
            link.classList.remove(activeClass);
          });

          // Set active state
          if (currentActive && headerToLinkMap[currentActive.id]) {
            headerToLinkMap[currentActive.id].classList.add(activeClass);
          } else if (tocLinks.length > 0 && scrollTop < 100) {
            // Activate first link when at top
            tocLinks[0].classList.add(activeClass);
          }
        } catch (updateError) {
          console.warn('Error updating active section:', updateError);
        }
      }

      // Initialize header positions
      updateHeaderPositions();

      // Optimized scroll handler with throttling for 60fps performance (Requirement 3.4)
      var optimizedScrollHandler = throttle(updateActiveSection, 16); // ~60fps
      var eventOptions = features.passiveEvents ? { passive: true } : false;

      window.addEventListener('scroll', optimizedScrollHandler, eventOptions);

      // Optimized resize handler with debouncing
      var optimizedResizeHandler = debounce(updateHeaderPositions, 250);
      window.addEventListener('resize', optimizedResizeHandler, eventOptions);

      // Initial update
      updateActiveSection();

      console.log('Fallback scroll-based active highlighting initialized');

    } catch (error) {
      console.error('Error initializing fallback highlighting:', error);
    }
  }

  // TOC Resize Functionality with localStorage persistence (Requirements 3.4, 3.5, 3.6, 3.7)
  function initializeTOCResize() {
    try {
      var tocSidebar = document.querySelector('.toc-sidebar');
      if (!tocSidebar) {
        console.log('TOC sidebar not found, skipping resize initialization');
        return;
      }

      // Check if we're on mobile/tablet (resize should be disabled)
      var mediaQuery = window.matchMedia('(max-width: 1024px)');
      if (mediaQuery.matches) {
        console.log('Resize disabled on mobile/tablet devices');
        return;
      }

      // Restore saved width from localStorage (Requirement 3.5)
      try {
        var savedWidth = localStorage.getItem('toc-width');
        if (savedWidth) {
          var width = parseInt(savedWidth, 10);
          // Validate bounds (200-400px) (Requirement 3.6)
          if (width >= 200 && width <= 400) {
            tocSidebar.style.width = width + 'px';
            console.log('Restored TOC width from localStorage: ' + width + 'px');
          } else {
            console.warn('Saved TOC width out of bounds (' + width + 'px), using default');
          }
        }
      } catch (storageError) {
        console.warn('Could not restore TOC width from localStorage:', storageError);
      }

      // Use ResizeObserver to detect width changes (Requirement 3.6)
      if ('ResizeObserver' in window) {
        // Debounced save function to prevent excessive localStorage writes (Requirement 3.6)
        var debouncedSave = debounce(function (width) {
          try {
            localStorage.setItem('toc-width', Math.round(width));
            console.log('Saved TOC width to localStorage: ' + Math.round(width) + 'px');
          } catch (e) {
            console.warn('Could not save TOC width to localStorage:', e);
          }
        }, 300);

        var resizeObserver = new ResizeObserver(function (entries) {
          try {
            for (var i = 0; i < entries.length; i++) {
              var entry = entries[i];
              var width = entry.contentRect.width;

              // Enforce bounds (200-400px) (Requirement 3.6)
              if (width < 200) {
                tocSidebar.style.width = '200px';
                width = 200;
              } else if (width > 400) {
                tocSidebar.style.width = '400px';
                width = 400;
              }

              // Save to localStorage (debounced) (Requirement 3.5)
              debouncedSave(width);
            }
          } catch (observerError) {
            console.warn('Error in ResizeObserver callback:', observerError);
          }
        });

        resizeObserver.observe(tocSidebar);

        // Store observer reference for cleanup (Requirement 3.7)
        window.tocResizeObserver = resizeObserver;

        // Cleanup on page unload (Requirement 3.7)
        window.addEventListener('beforeunload', function () {
          if (window.tocResizeObserver) {
            window.tocResizeObserver.disconnect();
            window.tocResizeObserver = null;
            console.log('TOC ResizeObserver disconnected');
          }
        });

        console.log('TOC resize functionality initialized with ResizeObserver');
      } else {
        // Graceful degradation when ResizeObserver is not supported (Requirement 3.7)
        console.warn('ResizeObserver not supported - resize will work but without bounds enforcement or localStorage persistence');
      }

    } catch (error) {
      console.error('Error initializing TOC resize functionality:', error);
    }
  }

  // Initialize resize functionality after TOC is loaded
  // This should be called after the TOC is generated
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function () {
      setTimeout(initializeTOCResize, 100); // Small delay to ensure TOC is rendered
    });
  } else {
    setTimeout(initializeTOCResize, 100); // Small delay to ensure TOC is rendered
  }
</script>
    </aside>
    <main class="post-main">
      <div class="post-content e-content" itemprop="articleBody">
        <h1 id="introduction">Introduction</h1>

<p><a href="https://mani2106.github.io/Blog-Posts/azure/azure-ai/ai-102/2025/11/15/Azure-AI102-Day1-Planning-AI-Soln-Azure.html">In the previous notes</a> I mentioned a lot of Azure’s product offerings and how they can be combined and used within a real word project setting.</p>

<p>Today, I will try to write about what I learnt from the Responsible AI module in the same lesson and about the questions in the sample assessment.</p>

<h1 id="responsible-ai">Responsible AI</h1>

<p>They talk about some core principles for responsible AI that have been adopted at Microsoft.</p>

<h2 id="fairness">Fairness</h2>

<p>The AI model will learn what is present in the data, so it pays to be cautious and ensure that the AI model consider all people fairly. So carefully reviewing training data to be representative of all the potentially affected subjects and evaluating predictive performance for subsections of your user population throughout the development lifecycle.</p>

<p>I have not worked in a lot of applications that have had me to deal with data of people, except one where I was participating in a ML competition long back, where I was tasked to predict a loan default probability for a given loan application, I carefully engineered a lot of features using offered data like credit scores, educational qualification, monthly spending trends, but there was also another feature that was pretty much controversial, <strong>(ie) Gender</strong>. No matter what I did, the prediction scores that I got after including <strong>Gender</strong> in the features was unmatchable. However, this may resulted in a lot of unfair predictions, so It is always tempting but it is very crucial to avoid letting bias creep in to the model, because it is not ethical, and also in other scenarios they can be very hard to debug.</p>

<h2 id="reliability-and-safety">Reliability and Safety</h2>

<p>We should ensure that we have sufficient guardrails in place to make the models more reliable and compliant to all the laws that are applicable given the scenario. Ensuring correct thresholds are chosen the usecase at hand. For eg:</p>

<h3 id="imaginary-scenario-smart-triage-assistant-for-a-clinic">Imaginary scenario: “Smart Triage Assistant” for a clinic</h3>
<ul>
  <li>Problem: An AI model scores incoming patient symptom reports 0–1 for urgency and automatically queues patients for immediate attention if the score &gt; 0.85.</li>
  <li>Guardrails and safety measures:
    <ul>
      <li>Thresholds and human review: Scores &gt; 0.95 → auto-escalate; scores 0.85–0.95 → flag for clinician review before escalation; scores &lt; 0.85 → normal workflow. This prevents over-automating borderline cases.</li>
      <li>Confidence calibration: Use calibrated probabilities and require minimum confidence for automatic actions.</li>
      <li>Out‑of‑distribution detection: If patient data looks very different (new symptoms, missing fields), route to human triage rather than trusting model output.</li>
      <li>Monitoring and alerts: Continuously monitor score distribution, false negatives/positives, and trigger alerts if drift or sudden error-rate spikes appear.</li>
      <li>Explainability and logging: Log model inputs, predictions, and explanations so clinicians can understand why a decision was made and audit later.</li>
      <li>Safe fallback and rate limits: If the model service fails or latency spikes, fall back to manual triage and rate-limit automated escalations.</li>
      <li>Periodic fairness checks: Ensure model performance is comparable across age, gender, ethnicity groups and retrain or adjust if disparities appear.</li>
      <li>Regulatory and privacy controls: Mask or minimize sensitive fields, keep audit trails, and obtain required consents.</li>
    </ul>
  </li>
</ul>

<p>These simple measures—thresholds, human‑in‑the‑loop for uncertain cases, continuous monitoring, explainability, and safe fallbacks—help keep the system reliable and safe in production.</p>

<h2 id="inclusiveness">Inclusiveness</h2>

<p>This also can be understood as a tangent to Fairness, One way to optimize for inclusiveness is to ensure that the design, development, and testing of your application includes input from as diverse a group of people as possible. Practical steps include designing accessible interfaces, supporting multiple languages, and testing with diverse user groups to capture different needs. Following accessibility and localization best practices helps ensure the solution works well for a wide range of users.</p>

<h2 id="transparency">Transparency</h2>

<p>AI systems are required to be transparent to ensure that the system as a whole to ensure compliance with laws and to be able to debug and understand them better.</p>

<h2 id="accountability">Accountability</h2>

<p>We should be accountable for AI systems that we build. Although many AI systems seem to operate autonomously, ultimately it’s our responsibility as who trained and validated the models people use, and defined the logic that bases decisions on model predictions to ensure that the overall system meets responsibility requirements.</p>

<p>This section was not very technical I will now go to the <strong>Module Assessment</strong></p>

<h1 id="module-assessment">Module Assessment</h1>

<ul>
  <li>The first question asks which Azure resource provides language and vision services from a single endpoint. The correct answer is Azure AI Services, which integrates various AI capabilities, allowing developers to utilize both language processing and vision recognition in their applications.</li>
  <li>For the second question, it focuses on creating a chat app that uses a generative AI model. The recommended project type for this scenario is an Azure AI Foundry project, which is designed to facilitate the development of AI-driven applications.</li>
  <li>Lastly, the third question inquires about the SDK that enables you to connect to resources in a project. The Azure AI Services SDK is the appropriate choice for this purpose, as it provides the necessary tools and libraries to interact with Azure’s AI services effectively. To deepen your understanding, reviewing Azure documentation and engaging with training materials can provide further insights into these topics.</li>
</ul>

      </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="mani2106/Blog-Posts"
        issue-term="title"
        label="💬blog-comment"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/Blog-Posts/azure/azure-ai/ai-102/2025/11/17/Azure-AI102-Day2-Planning-AI-Soln-Azure.html" hidden></a>
    </main>
  </div>

  <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
  <svg class="theme-icon theme-icon-sun" width="20" height="20" viewBox="0 0 20 20" aria-hidden="true">
    <circle cx="10" cy="10" r="5" fill="currentColor"/>
    <g stroke="currentColor" stroke-width="2" stroke-linecap="round">
      <line x1="10" y1="1" x2="10" y2="3"/>
      <line x1="10" y1="17" x2="10" y2="19"/>
      <line x1="1" y1="10" x2="3" y2="10"/>
      <line x1="17" y1="10" x2="19" y2="10"/>
      <line x1="3.5" y1="3.5" x2="5" y2="5"/>
      <line x1="15" y1="15" x2="16.5" y2="16.5"/>
      <line x1="16.5" y1="3.5" x2="15" y2="5"/>
      <line x1="5" y1="15" x2="3.5" y2="16.5"/>
    </g>
  </svg>
  <svg class="theme-icon theme-icon-moon" width="20" height="20" viewBox="0 0 20 20" aria-hidden="true">
    <path d="M17 12.5A7.5 7.5 0 1 1 9.5 2a6 6 0 0 0 7.5 10.5z" fill="currentColor"/>
  </svg>
</button>

</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/Blog-Posts/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/Blog-Posts/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/Blog-Posts/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Manimaran Panneerselvam</li>
          <li><a class="u-email" href="mailto:manimaran_p@outlook.com">manimaran_p@outlook.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>This is where I write about my work on data science. I will also post Notebooks and sample codes to solve some interesting problems that I face everyday.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/mani2106" target="_blank" title="mani2106"><svg class="svg-icon grey"><use xlink:href="/Blog-Posts/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://www.linkedin.com/in/manimaran-p" target="_blank" title="manimaran-p"><svg class="svg-icon grey"><use xlink:href="/Blog-Posts/assets/minima-social-icons.svg#linkedin"></use></svg></a></li><li><a rel="me" href="https://twitter.com/mani_maranp" target="_blank" title="mani_maranp"><svg class="svg-icon grey"><use xlink:href="/Blog-Posts/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
